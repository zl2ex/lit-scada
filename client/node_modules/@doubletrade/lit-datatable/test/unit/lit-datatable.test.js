import { fixture, html, expect, elementUpdated } from '@open-wc/testing';
import sinon from 'sinon';
import '../../lit-datatable';
class LitDatatableTest {
    async init(conf, data, stickyHeader) {
        const litDatatable = html `
      <lit-datatable .conf="${conf}" .data="${data}" .stickyHeader="${!!stickyHeader}"></lit-datatable>
    `;
        this.el = await fixture(litDatatable);
        return this.elementUpdated();
    }
    elementUpdated() {
        return elementUpdated(this.el);
    }
    get bodyTrs() {
        var _a;
        if ((_a = this === null || this === void 0 ? void 0 : this.el) === null || _a === void 0 ? void 0 : _a.shadowRoot) {
            return this.el.shadowRoot.querySelectorAll('tbody tr');
        }
        return null;
    }
    get bodyTds() {
        var _a;
        if ((_a = this === null || this === void 0 ? void 0 : this.el) === null || _a === void 0 ? void 0 : _a.shadowRoot) {
            return this.el.shadowRoot.querySelectorAll('tbody td');
        }
        return null;
    }
    get headTrs() {
        var _a;
        if ((_a = this === null || this === void 0 ? void 0 : this.el) === null || _a === void 0 ? void 0 : _a.shadowRoot) {
            return this.el.shadowRoot.querySelectorAll('thead tr');
        }
        return null;
    }
    get headThs() {
        var _a;
        if ((_a = this === null || this === void 0 ? void 0 : this.el) === null || _a === void 0 ? void 0 : _a.shadowRoot) {
            return this.el.shadowRoot.querySelectorAll('thead th');
        }
        return null;
    }
}
const basicData = [
    { fruit: 'apple', color: 'green', weight: '100gr' },
    { fruit: 'banana', color: 'yellow', weight: '140gr' },
];
const basicDataWithSubObject = [
    { fruit: 'apple', color: 'green', weight: { value: '100gr' } },
    { fruit: 'banana', color: 'yellow', weight: { value: '140gr' } },
];
const basicConf = [
    { property: 'fruit', header: 'Fruit', hidden: false },
    { property: 'color', header: 'Color', hidden: false },
    { property: 'weight', header: 'Weight', hidden: false },
];
const basicConfWithSubObject = [
    { property: 'fruit', header: 'Fruit', hidden: false },
    { property: 'color', header: 'Color', hidden: false },
    { property: 'weight.value', header: 'Weight', hidden: false },
];
describe('lit-datatable', () => {
    it('counts', async () => {
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        const { bodyTrs, bodyTds, headTrs, headThs, } = litDatatable;
        expect(headTrs === null || headTrs === void 0 ? void 0 : headTrs.length).to.be.equal(1);
        expect(headThs === null || headThs === void 0 ? void 0 : headThs.length).to.be.equal(3);
        expect(bodyTrs === null || bodyTrs === void 0 ? void 0 : bodyTrs.length).to.be.equal(2);
        expect(bodyTds === null || bodyTds === void 0 ? void 0 : bodyTds.length).to.be.equal(6);
    });
    it('header values', async () => {
        var _a, _b, _c;
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        const { headThs } = litDatatable;
        expect(headThs).to.be.not.equal(null);
        if (headThs) {
            expect((_a = headThs[0]) === null || _a === void 0 ? void 0 : _a.textContent).to.be.equal('Fruit');
            expect((_b = headThs[1]) === null || _b === void 0 ? void 0 : _b.textContent).to.be.equal('Color');
            expect((_c = headThs[2]) === null || _c === void 0 ? void 0 : _c.textContent).to.be.equal('Weight');
        }
    });
    it('body values', async () => {
        var _a, _b, _c, _d, _e, _f;
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        const { bodyTds } = litDatatable;
        expect(bodyTds).to.be.not.equal(null);
        if (bodyTds) {
            expect((_a = bodyTds[0]) === null || _a === void 0 ? void 0 : _a.textContent).to.be.equal('apple');
            expect((_b = bodyTds[1]) === null || _b === void 0 ? void 0 : _b.textContent).to.be.equal('green');
            expect((_c = bodyTds[2]) === null || _c === void 0 ? void 0 : _c.textContent).to.be.equal('100gr');
            expect((_d = bodyTds[3]) === null || _d === void 0 ? void 0 : _d.textContent).to.be.equal('banana');
            expect((_e = bodyTds[4]) === null || _e === void 0 ? void 0 : _e.textContent).to.be.equal('yellow');
            expect((_f = bodyTds[5]) === null || _f === void 0 ? void 0 : _f.textContent).to.be.equal('140gr');
        }
    });
    it('body values with sub object', async () => {
        var _a, _b, _c, _d, _e, _f;
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConfWithSubObject, basicDataWithSubObject);
        await litDatatable.elementUpdated();
        const { bodyTds } = litDatatable;
        expect(bodyTds).to.be.not.equal(null);
        if (bodyTds) {
            expect((_a = bodyTds[0]) === null || _a === void 0 ? void 0 : _a.textContent).to.be.equal('apple');
            expect((_b = bodyTds[1]) === null || _b === void 0 ? void 0 : _b.textContent).to.be.equal('green');
            expect((_c = bodyTds[2]) === null || _c === void 0 ? void 0 : _c.textContent).to.be.equal('100gr');
            expect((_d = bodyTds[3]) === null || _d === void 0 ? void 0 : _d.textContent).to.be.equal('banana');
            expect((_e = bodyTds[4]) === null || _e === void 0 ? void 0 : _e.textContent).to.be.equal('yellow');
            expect((_f = bodyTds[5]) === null || _f === void 0 ? void 0 : _f.textContent).to.be.equal('140gr');
        }
    });
    it('change column position', async () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        const { bodyTds } = litDatatable;
        expect(bodyTds).to.be.not.equal(null);
        if (bodyTds) {
            expect((_a = bodyTds[0]) === null || _a === void 0 ? void 0 : _a.textContent).to.be.equal('apple');
            expect((_b = bodyTds[1]) === null || _b === void 0 ? void 0 : _b.textContent).to.be.equal('green');
            expect((_c = bodyTds[2]) === null || _c === void 0 ? void 0 : _c.textContent).to.be.equal('100gr');
            expect((_d = bodyTds[3]) === null || _d === void 0 ? void 0 : _d.textContent).to.be.equal('banana');
            expect((_e = bodyTds[4]) === null || _e === void 0 ? void 0 : _e.textContent).to.be.equal('yellow');
            expect((_f = bodyTds[5]) === null || _f === void 0 ? void 0 : _f.textContent).to.be.equal('140gr');
        }
        const newConfPosition = [
            { property: 'weight', header: 'Weight', hidden: false },
            { property: 'color', header: 'Color', hidden: false },
            { property: 'fruit', header: 'Fruit', hidden: false },
        ];
        litDatatable.el.conf = newConfPosition;
        await litDatatable.elementUpdated();
        if (bodyTds) {
            expect((_g = bodyTds[0]) === null || _g === void 0 ? void 0 : _g.textContent).to.be.equal('100gr');
            expect((_h = bodyTds[1]) === null || _h === void 0 ? void 0 : _h.textContent).to.be.equal('green');
            expect((_j = bodyTds[2]) === null || _j === void 0 ? void 0 : _j.textContent).to.be.equal('apple');
            expect((_k = bodyTds[3]) === null || _k === void 0 ? void 0 : _k.textContent).to.be.equal('140gr');
            expect((_l = bodyTds[4]) === null || _l === void 0 ? void 0 : _l.textContent).to.be.equal('yellow');
            expect((_m = bodyTds[5]) === null || _m === void 0 ? void 0 : _m.textContent).to.be.equal('banana');
        }
    });
    it('hide column', async () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        let bodyTrs;
        let bodyTds;
        let headTrs;
        let headThs;
        ({
            bodyTrs, bodyTds, headTrs, headThs,
        } = litDatatable);
        expect(headTrs === null || headTrs === void 0 ? void 0 : headTrs.length).to.be.equal(1);
        expect(headThs === null || headThs === void 0 ? void 0 : headThs.length).to.be.equal(3);
        expect(bodyTrs === null || bodyTrs === void 0 ? void 0 : bodyTrs.length).to.be.equal(2);
        expect(bodyTds === null || bodyTds === void 0 ? void 0 : bodyTds.length).to.be.equal(6);
        expect(bodyTds).to.be.not.equal(null);
        if (bodyTds) {
            expect((_a = bodyTds[0]) === null || _a === void 0 ? void 0 : _a.textContent).to.be.equal('apple');
            expect((_b = bodyTds[1]) === null || _b === void 0 ? void 0 : _b.textContent).to.be.equal('green');
            expect((_c = bodyTds[2]) === null || _c === void 0 ? void 0 : _c.textContent).to.be.equal('100gr');
            expect((_d = bodyTds[3]) === null || _d === void 0 ? void 0 : _d.textContent).to.be.equal('banana');
            expect((_e = bodyTds[4]) === null || _e === void 0 ? void 0 : _e.textContent).to.be.equal('yellow');
            expect((_f = bodyTds[5]) === null || _f === void 0 ? void 0 : _f.textContent).to.be.equal('140gr');
        }
        const newConf = [
            { property: 'weight', header: 'Weight', hidden: false },
            { property: 'color', header: 'Color', hidden: true },
            { property: 'fruit', header: 'Fruit', hidden: false },
        ];
        litDatatable.el.conf = newConf;
        await litDatatable.elementUpdated();
        ({
            bodyTrs, bodyTds, headTrs, headThs,
        } = litDatatable);
        expect(headTrs === null || headTrs === void 0 ? void 0 : headTrs.length).to.be.equal(1);
        expect(headThs === null || headThs === void 0 ? void 0 : headThs.length).to.be.equal(2);
        expect(bodyTrs === null || bodyTrs === void 0 ? void 0 : bodyTrs.length).to.be.equal(2);
        expect(bodyTds === null || bodyTds === void 0 ? void 0 : bodyTds.length).to.be.equal(4);
        expect(bodyTds).to.be.not.equal(null);
        if (bodyTds) {
            expect((_g = bodyTds[0]) === null || _g === void 0 ? void 0 : _g.textContent).to.be.equal('100gr');
            expect((_h = bodyTds[1]) === null || _h === void 0 ? void 0 : _h.textContent).to.be.equal('apple');
            expect((_j = bodyTds[2]) === null || _j === void 0 ? void 0 : _j.textContent).to.be.equal('140gr');
            expect((_k = bodyTds[3]) === null || _k === void 0 ? void 0 : _k.textContent).to.be.equal('banana');
        }
    });
    it('change data length', async () => {
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        let bodyTrs;
        let bodyTds;
        let headTrs;
        let headThs;
        ({
            bodyTrs, bodyTds, headTrs, headThs,
        } = litDatatable);
        expect(headTrs === null || headTrs === void 0 ? void 0 : headTrs.length).to.be.equal(1);
        expect(headThs === null || headThs === void 0 ? void 0 : headThs.length).to.be.equal(3);
        expect(bodyTrs === null || bodyTrs === void 0 ? void 0 : bodyTrs.length).to.be.equal(2);
        expect(bodyTds === null || bodyTds === void 0 ? void 0 : bodyTds.length).to.be.equal(6);
        // Add row
        const addRow = [
            { fruit: 'apple', color: 'green', weight: '100gr' },
            { fruit: 'banana', color: 'yellow', weight: '140gr' },
            { fruit: 'cherry', color: 'red', weight: '40gr' },
        ];
        litDatatable.el.data = addRow;
        await litDatatable.elementUpdated();
        ({
            bodyTrs, bodyTds, headTrs, headThs,
        } = litDatatable);
        expect(headTrs === null || headTrs === void 0 ? void 0 : headTrs.length).to.be.equal(1);
        expect(headThs === null || headThs === void 0 ? void 0 : headThs.length).to.be.equal(3);
        expect(bodyTrs === null || bodyTrs === void 0 ? void 0 : bodyTrs.length).to.be.equal(3);
        expect(bodyTds === null || bodyTds === void 0 ? void 0 : bodyTds.length).to.be.equal(9);
        // Delete row
        const deleteRow = [
            { fruit: 'apple', color: 'green', weight: '100gr' },
        ];
        litDatatable.el.data = deleteRow;
        await litDatatable.elementUpdated();
        ({
            bodyTrs, bodyTds, headTrs, headThs,
        } = litDatatable);
        expect(headTrs === null || headTrs === void 0 ? void 0 : headTrs.length).to.be.equal(1);
        expect(headThs === null || headThs === void 0 ? void 0 : headThs.length).to.be.equal(3);
        expect(bodyTrs === null || bodyTrs === void 0 ? void 0 : bodyTrs.length).to.be.equal(1);
        expect(bodyTds === null || bodyTds === void 0 ? void 0 : bodyTds.length).to.be.equal(3);
    });
    it('tr tap event', async () => {
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        const { bodyTrs } = litDatatable;
        expect(bodyTrs).to.be.not.equal(null);
        if (bodyTrs) {
            const tapEventSpy = sinon.spy();
            const tapEvent = new Event('tap');
            litDatatable.el.addEventListener('tap-tr', tapEventSpy);
            bodyTrs[0].dispatchEvent(tapEvent);
            expect(tapEventSpy.callCount).to.be.equal(1);
        }
    });
    it('tr mouseover event', async () => {
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        const { bodyTrs } = litDatatable;
        expect(bodyTrs).to.be.not.equal(null);
        if (bodyTrs) {
            const mouseEventSpy = sinon.spy();
            const mouseEvent = new Event('mouseover');
            litDatatable.el.addEventListener('tr-mouseover', mouseEventSpy);
            bodyTrs[0].dispatchEvent(mouseEvent);
            expect(mouseEventSpy.callCount).to.be.equal(1);
        }
    });
    it('tr mouseout event', async () => {
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData);
        await litDatatable.elementUpdated();
        const { bodyTrs } = litDatatable;
        expect(bodyTrs).to.be.not.equal(null);
        if (bodyTrs) {
            const mouseEventSpy = sinon.spy();
            const mouseEvent = new Event('mouseout');
            litDatatable.el.addEventListener('tr-mouseout', mouseEventSpy);
            bodyTrs[0].dispatchEvent(mouseEvent);
            expect(mouseEventSpy.callCount).to.be.equal(1);
        }
    });
    it('sticky header', async () => {
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData, true);
        await litDatatable.elementUpdated();
        const { headThs } = litDatatable;
        expect(headThs).to.be.not.equal(null);
        if (headThs) {
            const eachThIsSticky = Array.from(headThs).every((th) => th.classList.contains('sticky'));
            expect(eachThIsSticky).to.be.equal(true);
        }
    });
    it('non sticky header', async () => {
        const litDatatable = new LitDatatableTest();
        await litDatatable.init(basicConf, basicData, false);
        await litDatatable.elementUpdated();
        const { headThs } = litDatatable;
        expect(headThs).to.be.not.equal(null);
        if (headThs) {
            const eachThIsSticky = Array.from(headThs).every((th) => th.classList.contains('sticky'));
            expect(eachThIsSticky).to.be.equal(false);
        }
    });
});
//# sourceMappingURL=lit-datatable.test.js.map